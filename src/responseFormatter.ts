import { RequestIntent } from './intent';
import { calculatePatchStatistics, PatchStatistics, truncatePatchIfNeeded } from './utils';
import { GitHubContext, Reaction, addReaction, addContextualReaction, ContextualReactionType } from './github';
import { log, logWarning, logSuccess } from './utils';

interface FormatResponseOptions {
  intent: RequestIntent;
  content: string; // This could be patch content, AI analysis, etc.
  githubContext: GitHubContext;
  executionTime: string;
  modelName: string; // Model used for generation (SWE-Agent or LLM)
  patchStatistics?: PatchStatistics; // Optional, for patch responses
  wasTruncated?: boolean; // Optional, for patch responses
}

function getContextEmojiDescription(githubContext: GitHubContext): { emoji: string; description: string } {
  if (githubContext.isPullRequest) {
    if (githubContext.eventName === 'pull_request_review' || githubContext.eventName === 'pull_request_review_comment') {
      return { emoji: 'üîç', description: 'PR Review' };
    }
    return { emoji: 'üîÑ', description: 'Pull Request' };
  }
  if (githubContext.eventName === 'issue_comment' || githubContext.eventName === 'issues') {
    return { emoji: 'üìù', description: 'Issue' };
  }
  return { emoji: 'ü§ñ', description: 'Request' }; // Default
}

function formatBaseResponseHeader(
  titlePrefix: string,
  options: FormatResponseOptions,
  responseType: string
): string {
  const { githubContext, executionTime, modelName } = options;
  const { description } = getContextEmojiDescription(githubContext);
  const issueOrPrNumber = githubContext.prNumber || githubContext.issueNumber;
  const issueOrPrTitle = githubContext.prTitle || githubContext.issueTitle || 'N/A';

  return `
${titlePrefix}

**${description}:** #${issueOrPrNumber} - ${issueOrPrTitle}
**Context:** ${githubContext.detectedContextType} (Event: ${githubContext.eventName})
**Model:** ${modelName}
**Response Type:** ${responseType}
**Time:** ${executionTime}
`;
}

function formatFooter(options: FormatResponseOptions): string {
  const { modelName, githubContext } = options;
  const { emoji } = getContextEmojiDescription(githubContext);
  return `
---
*Generated by SWE-Agent (${modelName}) ‚Ä¢ ${emoji} ${githubContext.detectedContextType} context*`;
}

function formatPrReviewResponse(options: FormatResponseOptions): string {
  const header = formatBaseResponseHeader('üîç **SWE-Agent Pull Request Review**', options, 'Comprehensive PR Analysis');
  const footer = formatFooter(options);
  // Simplified content from shell script, can be expanded with actual metrics if AI provides them
  return `
${header}
## üìã Pull Request Review Summary

${options.content}

## üîç Code Quality Assessment (Template)

<details>
<summary>üìä Click to view detailed code quality metrics</summary>

**Architecture & Design:** (AI to fill)
**Security & Safety:** (AI to fill)
**Performance & Efficiency:** (AI to fill)
**Testing & Coverage:** (AI to fill)

</details>

## üéØ Review Recommendations (Template)

(AI to fill with specific recommendations and overall assessment: ‚úÖ APPROVED / ‚ö†Ô∏è APPROVED WITH SUGGESTIONS / ‚ùå CHANGES REQUESTED)

${footer}
`;
}

function formatOpinionResponse(options: FormatResponseOptions): string {
  const header = formatBaseResponseHeader('üí° **SWE-Agent Opinion & Recommendations**', options, 'Opinion & Advice');
  const footer = formatFooter(options);
  return `
${header}
## ü§î My Analysis & Opinion

${options.content}

## üí° Key Recommendations

<details>
<summary>üéØ Click to view detailed recommendations</summary>

${options.content} 
</details>

## üöÄ Next Steps (Example)
1. **Consider the trade-offs** mentioned.
2. **Test thoroughly** if applicable.

${footer}
`;
}

function formatAnalysisResponse(options: FormatResponseOptions): string {
  const header = formatBaseResponseHeader('üîç **SWE-Agent Code Analysis Report**', options, 'Technical Analysis');
  const footer = formatFooter(options);
  return `
${header}
## üìä Analysis Results

${options.content}

## üîç Technical Details (Template)

<details>
<summary>üìã Click to view detailed technical analysis</summary>

${options.content}
</details>

## üéØ Key Findings (Example)
- **Architecture Impact:** (AI to fill)
- **Performance Considerations:** (AI to fill)

${footer}
`;
}

function formatVisualResponse(options: FormatResponseOptions): string {
  const header = formatBaseResponseHeader('üìä **SWE-Agent Visual Analysis**', options, 'Visual Content');
  const footer = formatFooter(options);
  return `
${header}
## üìà Generated Visualization

${options.content} 

## üé® Visual Content Details (Example)

<details>
<summary>üñºÔ∏è Click to view details or alternative formats</summary>

${options.content}
</details>

${footer}
`;
}

function formatPatchSuccessResponse(options: FormatResponseOptions): string {
  const { githubContext, executionTime, modelName, content: patchContent, patchStatistics, wasTruncated } = options;
  const { description } = getContextEmojiDescription(githubContext);
  const issueOrPrNumber = githubContext.prNumber || githubContext.issueNumber;
  const issueOrPrTitle = githubContext.prTitle || githubContext.issueTitle || 'N/A';
  const gitRefShort = githubContext.sha.substring(0, 8);

  let statsSummary = '';
  if (patchStatistics && patchStatistics.filesChanged > 0) {
    statsSummary = `**üìä Patch Statistics:**
- üìÅ Files changed: **${patchStatistics.filesChanged}**
- ‚ûï Lines added: **${patchStatistics.linesAdded}**
- ‚ûñ Lines removed: **${patchStatistics.linesRemoved}**
- üìè Net change: **${patchStatistics.linesAdded - patchStatistics.linesRemoved}** lines`;
    if (wasTruncated) {
      // Correctly append to template string using backticks for the newline
      statsSummary += `\\n- ‚ö†Ô∏è **Note:** Patch was truncated for display (full patch in PR/commit).`;
    }
  }

  const contextAction = githubContext.isPullRequest ? "updated the existing Pull Request" : "created a new solution";

  // Corrected markdown for diff block using triple backticks
  return `
‚úÖ **Solution Generated Successfully!**

**${description}:** #${issueOrPrNumber} - ${issueOrPrTitle}
**Context:** ${githubContext.detectedContextType} (Event: ${githubContext.eventName})
**Model:** ${modelName}
**Execution Time:** ${executionTime}
**Git Reference:** ${gitRefShort}...

${statsSummary}

## üîß Generated Patch

<details>
<summary>üìÑ Click to view generated patch (${patchStatistics?.filesChanged || 0} files changed)</summary>

\`\`\`diff
${patchContent}
\`\`\`

</details>

## üîÑ Next Steps
‚ú® The patch is being processed and ${contextAction}.

**What happens next (example):**
1. üîÑ Patch validation and testing.
2. üìù Pull Request creation/update with detailed description.
3. ‚úÖ Ready for review and merge.

${formatFooter(options)}
`;
}

function formatNoPatchMessage(options: FormatResponseOptions): string {
    const { githubContext, executionTime, modelName } = options;
    const issueOrPrNumber = githubContext.prNumber || githubContext.issueNumber;
    const issueOrPrTitle = githubContext.prTitle || githubContext.issueTitle || 'N/A';

    return `
üîç **Analysis Completed - No Code Changes Generated**

**Issue/PR:** #${issueOrPrNumber} - ${issueOrPrTitle}
**Model:** ${modelName}
**Execution Time:** ${executionTime}

I've analyzed the request but didn't generate a code patch. This could be because:
- The request was for analysis, opinion, or visualization.
- The issue might not require a code change (e.g., documentation, configuration, or already resolved).
- More information or a more specific prompt is needed.

<details>
<summary>üéØ Tips for requests expecting code changes</summary>

- **Be specific:** "Fix error X in file Y, function Z" is better than "Fix login."
- **Provide context:** Include error messages, steps to reproduce, and expected behavior.
</details>

${formatFooter(options)}
`;
}


export function formatResponse(options: FormatResponseOptions): string {
  switch (options.intent) {
    case RequestIntent.PRReview:
      return formatPrReviewResponse(options);
    case RequestIntent.Opinion:
      return formatOpinionResponse(options);
    case RequestIntent.Analysis:
      return formatAnalysisResponse(options);
    case RequestIntent.Visual:
      return formatVisualResponse(options);
    case RequestIntent.Patch:
      if (!options.content || options.content.trim() === '') {
        if (options.patchStatistics && options.patchStatistics.filesChanged === 0 && options.patchStatistics.linesAdded === 0 && options.patchStatistics.linesRemoved === 0) {
            return formatNoPatchMessage(options);
        }
        return formatNoPatchMessage(options);
      }
      const stats = options.patchStatistics || calculatePatchStatistics(options.content);
      const { truncatedPatch, wasTruncated: truncated } = truncatePatchIfNeeded(options.content);
      return formatPatchSuccessResponse({
        ...options,
        content: truncatedPatch,
        patchStatistics: stats,
        wasTruncated: truncated,
      });
    default: 
      if (options.content && options.content.trim() !== '') {
        const defaultStats = calculatePatchStatistics(options.content);
        const { truncatedPatch: defaultTruncatedPatch, wasTruncated: defaultWasTruncated } = truncatePatchIfNeeded(options.content);
         return formatPatchSuccessResponse({
            ...options, 
            intent: RequestIntent.Patch, 
            content: defaultTruncatedPatch,
            patchStatistics: defaultStats,
            wasTruncated: defaultWasTruncated,
        });
      }
      return formatNoPatchMessage(options);
  }
}

export function simpleFormatPatchResponse(patchContent: string, githubContext: GitHubContext, execTime: string, model: string): string {
    const stats = calculatePatchStatistics(patchContent);
    const { truncatedPatch, wasTruncated } = truncatePatchIfNeeded(patchContent);
    const options: FormatResponseOptions = { // Explicitly type to ensure all fields are covered
        intent: RequestIntent.Patch,
        content: truncatedPatch,
        githubContext,
        executionTime: execTime,
        modelName: model,
        patchStatistics: stats,
        wasTruncated,
    };
    return formatResponse(options);
}

export function simpleFormatNoPatchResponse(githubContext: GitHubContext, execTime: string, model: string): string {
    const options: FormatResponseOptions = { // Explicitly type
        intent: RequestIntent.Patch, 
        content: '', 
        githubContext,
        executionTime: execTime,
        modelName: model,
    };
    return formatResponse(options);
}

export async function formatAndPostResponse(
  githubContext: GitHubContext,
  originalCommentId?: number,
  status?: 'success' | 'failure' | 'processing' | 'error'
): Promise<void> {
  log('Attempting to add reaction...');

  let reactionToPost: Reaction | ContextualReactionType = 'rocket'; // Default reaction

  if (status === 'success') {
    reactionToPost = 'rocket';
  } else if (status === 'failure') {
    reactionToPost = '-1';
  } else if (status === 'processing') {
    reactionToPost = 'eyes';
  } else if (status === 'error') {
    reactionToPost = 'confused';
  } else {
    log(`No specific status provided or unknown status '${status}', using default reaction '${reactionToPost}'.`);
  }

  if (!originalCommentId) {
    logWarning('Cannot add reaction: No originalCommentId provided.');
    return;
  }

  try {
    if (githubContext.isPullRequest) {
      if ([ '+1', '-1', 'laugh', 'confused', 'heart', 'hooray', 'rocket', 'eyes' ].includes(reactionToPost as string)) {
        await addContextualReaction(reactionToPost as ContextualReactionType, originalCommentId);
        logSuccess(`Contextual reaction '${reactionToPost}' added to PR comment ${originalCommentId}.`);
      } else {
        logWarning(`Reaction '${reactionToPost}' is not a valid ContextualReactionType for PR comment ${originalCommentId}.`);
      }
    } else { // Is an issue, and originalCommentId is present for an issue comment
      await addReaction(reactionToPost as Reaction, originalCommentId);
      // Corrected logSuccess to be a single template string argument
      logSuccess(`Reaction '${reactionToPost}' added to issue comment ${originalCommentId}.`);
    }
  } catch (error) {
    // Corrected logWarning to be a single template string argument
    logWarning(`Failed to add reaction to comment ${originalCommentId}: ${error instanceof Error ? error.message : String(error)}`);
  }
}
